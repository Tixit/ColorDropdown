{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap fef37d2b3d7c4c00c8b0","webpack:///./lib/utils.js","webpack:///./ColorDropdown.js","webpack:///./lib/DropButton.js","webpack:///./lib/Dropdown.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,C;;;;;;;;;;;AC3GA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,E;;;;;;;;;;;AC5GD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC5CD;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA,KAAK,kCAAkC;AACvC;AACA;AACA,KAAK;AACL,uDAAuD;AACvD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,iFAAiF;AACjF;AACA;AACA","file":"ColorDropdown-dev.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ColorDropdown\"] = factory();\n\telse\n\t\troot[\"ColorDropdown\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fef37d2b3d7c4c00c8b0","\r\n// returns true if the point intersects the element's bounds, false otherwise\r\nexports.isPointOver = function(x,y, element) {\r\n    var bounds = element.getBoundingClientRect()\r\n    return bounds.top <= y&&y <= bounds.bottom\r\n        && bounds.left <= x&&x <= bounds.right\r\n}\r\n\r\n// returns a style that can be applied to 'gem' so that 'gem' will get styled as if it were a child of 'pseudoparent'\r\nexports.getStandaloneStyle = function(psuedoparent, gem, pseudoparentStyle) {\r\n    var standaloneStyle = getStyleForComponent(pseudoparentStyle.componentStyleMap, gem)\r\n    if(standaloneStyle) {\r\n        standaloneStyle = standaloneStyle.copy()\r\n    } else {\r\n        standaloneStyle = Style({})\r\n    }\r\n\r\n    // give it the full computed style map it would have it were an actual child\r\n    var original = standaloneStyle.componentStyleMap\r\n    standaloneStyle.componentStyleMap = {}\r\n    if(psuedoparent.parent !== undefined)\r\n        merge(standaloneStyle.componentStyleMap, psuedoparent.parent.computedStyleMap)\r\n    merge(standaloneStyle.componentStyleMap, pseudoparentStyle.componentStyleMap, original)\r\n\r\n    return standaloneStyle\r\n}\r\n\r\n// returns the closest ancestor dom node that has a non-visible scroll type for the given axis\r\n// axis - either 'x' or 'y'\r\nexports.findOverflowView = function(domNode, axis) {\r\n    for(var overflowView = domNode.parentNode; overflowView !== null; overflowView = overflowView.parentNode) {\r\n        var overflowStyle = window.getComputedStyle(overflowView).getPropertyValue('overflow-'+axis)\r\n        if(overflowView.parentNode === document || (overflowStyle !== 'visible' && overflowStyle !== '')) {\r\n            break;\r\n        }\r\n    }\r\n    return overflowView\r\n}\r\n\r\n// style - an object returned from getComputedStyle\r\n// property - a css property\r\nexports.getStylePxAmount = function(style, property) {\r\n    var text = style.getPropertyValue(property)\r\n    return parseInt(text.slice(0,text.length-2), 10)\r\n}\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\r\n\r\n// from Gem's blockStyleUtils - todo: replace these with Gem.styleUtils at some point\r\n\r\n// gets the right style from the styleMap, depending on the gem's `name` and `label` (`label` styles take precedence)\r\n// takes the component's inheritance tree into account (relies on the gem.constructor.parent property)\r\nvar getStyleForComponent = exports.getStyleForComponent = function (styleMap, gem) {\r\n    if(styleMap === undefined)\r\n        return undefined\r\n\r\n    return getStyleForLabel(styleMap, gem) || getStyleForGemName(styleMap, gem)\r\n}\r\n\r\nvar getStyleForLabel = exports.getStyleForLabel = function(styleMap, gem) {\r\n    if(gem.label !== undefined && '$'+gem.label in styleMap) {\r\n        return styleMap['$'+gem.label]\r\n    }\r\n}\r\nvar getStyleForGemName = exports.getStyleForBlockName = function(styleMap, gem) {\r\n    var constructor = gem.constructor\r\n    while(constructor !== undefined) {\r\n        var style = styleMap[constructor.name]\r\n        if(style !== undefined) {\r\n            return style\r\n        } else {\r\n            constructor = constructor.parent\r\n        }\r\n    }\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/utils.js\n// module id = 0\n// module chunks = 0","var DropButton = require(\"./lib/DropButton\")\n\n// from style/common.js in Tixit\nvar mainHeaderColor = '#01428B'\nvar mainBackgroundColor = '#F0F3F4'\nvar mainBackgroundColor2 = '#E6E6E6'\nvar mainFontColor = '#55606E'\n\nregisterPlugin(proto(Gem, function(superclass) {\n    this.name = 'ColorDropdown'\n\n    this.defaultOptions = function() {\n        return {field:'status', states:{\n            open: 'gray', inProgress:'yellow', complete: 'green'\n        }}\n    }\n    this.requireFields = function(options) {\n        var result = {}\n        result[options.field] = {type:'choice', choices:['open','inProgress','complete'], initial:'open'}\n        return result\n    }\n\n    // options\n        // field - The name of the field to store the status in\n        // states - A map of state names to colors\n    this.build = function(ticket, optionsObservee, api) {\n        var that = this\n        var config = optionsObservee.subject\n        this.field = config.field\n\n        this.drop = DropButton(Block(), Block())\n        this.add(this.drop)\n\n        var states = this.states = Object.keys(config.states)\n        this.ticket = ticket; this.config = config\n\n        states.forEach(function(k) {\n            var colorBlock = Block('color')\n            var color = that.config.states[k]\n            colorBlock.domNode.style.backgroundColor = color\n\n            var item = Block('item', colorBlock,Text(k))\n            item.on('click', function() {\n                ticket.set(that.field, k)\n                that.drop.close()\n            })\n\n            that.drop.menu.add(item)\n        })\n\n        that.updateState()\n        ticket.get(that.field).on('change', function() {\n            that.updateState()\n        })\n\n        // this.button.on('click', function() {\n        //     var stateIndex = states.indexOf(ticket.subject.status)\n        //\n        //     var newStateIndex = stateIndex+1\n        //     if(newStateIndex >= states.length) {\n        //         newStateIndex = 0\n        //     }\n        //\n        //     ticket.set('status', states[newStateIndex])\n        // })\n    }\n\n    this.updateState = function() {\n        var stateIndex = this.states.indexOf(this.ticket.get(this.field).subject)\n        var color = this.config.states[this.states[stateIndex]]\n\n        this.drop.button.domNode.style.backgroundColor = color\n        this.domNode.title = this.ticket.get(this.field).subject\n    }\n\n    this.getStyle = function() {\n        return {\n            DropButton: {\n                $button: {\n                    cursor: 'pointer',\n                    height: 20,width:20, borderRadius: 10,\n                    margin: 5\n                },\n                $menu: {\n                    backgroundColor: mainBackgroundColor,\n                    border: '1px solid '+mainHeaderColor,\n                    color: mainFontColor,\n                    $item: {\n                        display:'flex', alignItems: 'center',\n\n                        backgroundColor: mainBackgroundColor2,\n                        borderTop: '1px solid '+mainBackgroundColor2,\n                        cursor: 'pointer',\n\n                        $$hover: {\n                            backgroundColor: 'white'\n                        },\n\n                        $color: {\n                            width: 20, height: 20, borderRadius: 10,\n                            margin: '2px 4px'\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n}))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./ColorDropdown.js\n// module id = 1\n// module chunks = 0","var utils = require(\"./utils\")\nvar Dropdown = require('./Dropdown')\n\n// A Dropdown that opens when you click on it, and closes when you click off it\nmodule.exports = proto(Dropdown, function(superclass) {\n    this.name = 'DropButton'\n\n    this.build = function(/*[label,]button, dropdown[, maintainDropdownPosition]*/) {\n        var that = this\n        superclass.build.apply(this, arguments)\n\n        this.virtualAncestors = [] // if any gem in here is clicked, close won't be triggered\n        this.on('mousedown', function(e) {\n            if(e.button === 0) { // normal click\n                that.open()\n            }\n        })\n    }\n\n    this.open = function() {\n        if(!this.isOpen) {\n            superclass.open.apply(this,arguments)\n\n            var that = this\n            setTimeout(function() { // have to do this in a timeout otherwise the handler will be triggered off the click that sets it up\n                document.addEventListener('mousedown', that.closeHandler = function(event) {\n                    var anyOver = that.virtualAncestors.concat(that.dropdown).some(function(gem) {\n                        return utils.isPointOver(event.pageX, event.pageY, gem.domNode)\n                    })\n\n                    if(!anyOver) {\n                        that.close()\n                    }\n                })\n            },0)\n        }\n    }\n    this.close = function() {\n        if(this.isOpen) {\n            document.removeEventListener('mousedown', this.closeHandler)\n            superclass.close.apply(this,arguments)\n            this.closeHandler = undefined\n        }\n    }\n})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/DropButton.js\n// module id = 2\n// module chunks = 0","var utils = require(\"./utils\")\n\nvar scrollStyle = Style({\n    overflowY: 'scroll' // // overflow:auto doesn't work right for some godawful stupid css reason - http://stackoverflow.com/questions/32148519/widthauto-not-working-right-for-absolutely-positioned-div-when-scroll-bar-is-pr#32148618\n})\n\n// A button that can open and close a custom dropdown component\n// emits:\n    // open - emitted when the dropdown is opened\n    // close - emitted when the dropdown is closed\n// states:\n    // direction - Vertical direction. Can either be 1 or -1. 1 means the menu is displayed below its button, -1 means the menu is displayed above its button.\n    // horizontalDirection - Either 1 or -1. 1 means the menu extends beyond the right side of the button, -1 means the menu extends beyond the left side of the button.\n    // height - Can either be undefined, or a number. If undefined, it means the height is not constrained. If defined, it gives the height in pixels the menu is constrained to.\n    // width - Can either be undefined, or a number. If undefined, it means the width is not constrained. If defined, it gives the width in pixels the menu is constrained to.\n// note that in styling this, you can style the menu (using $menu, or its gem selector) as if it were an actual child\nmodule.exports = proto(Gem, function(superclass) {\n    this.name = 'Dropdown'\n\n    // can be overridden for different default menu styles\n    this.dropdownMenuStyle = Style({\n        display: 'block',\n        position: 'absolute',\n        border: '1px solid black',\n        marginTop: 2,\n        padding: 2,\n        backgroundColor: 'white',\n        zIndex: 900,\n\n        $state: function(state) {\n            if(state.height !== undefined) {\n                return scrollStyle\n            }\n        }\n    })\n\n    this.defaultStyle = Style({\n        $setup: function(block, style) {\n            var standaloneMenuStyle = utils.getStandaloneStyle(block, block.dropdown, style)\n            var fullstandAloneMenuStyle = block.dropdownMenuStyle.mix(standaloneMenuStyle)\n            block.dropdown.style = fullstandAloneMenuStyle\n        },\n        $kill: function(block) {\n            block.dropdown.style = undefined\n        },\n\n        $wrapper: {\n            display: 'block',\n            position: 'static'\n        }\n    })\n\n    // dropdown - The component to display when the Dropdown is opened. Note that this is mutated by being given the label 'menu'\n        // dropdown.state:direction - set to either 1 if the menu is displayed below the button, and -1 if the menu is displayed above the button\n        // dropdown.state:height - set to the height of the dropdown if the height  needs to be constrained, undefined if it doesn't need to be constrained (this is useful to do things like set 'overflow' to 'scroll' for example)\n        // dropdown.getPotentialHeight() - (optional) If available, called to get the full potential height of the dropdown. If not available, defaults to the dropdown's scrollHeight\n    // maintainDropdownPosition - (default:true) If true, while the dropdown is open, it will be repositioned constantly so that it tracks the movement of the button Component\n    this.build = function(/*[label,]button, dropdown[, maintainDropdownPosition]*/) {\n        if(arguments[0] === undefined || typeof(arguments[0]) === 'string') {\n            var label = arguments[0]\n            var argn = 1\n        } else {\n            var argn = 0\n        }\n\n        this.button = arguments[argn]\n        this.menu = this.dropdown = arguments[argn+1] // this.dropdown is deprecated\n        this.maintainDropdownPosition = arguments[argn+2]\n        if(this.maintainDropdownPosition === undefined) {\n            this.maintainDropdownPosition = true\n        }\n\n        this.label = label\n        this.isOpen = false\n\n        this.menu.label = 'menu'\n        this.menu.domNode.style.position = 'absolute'\n\n        this.button.label = 'button'\n\n        this.add(this.button) // Block('wrapper', [buttonComponent/*, dropdown])) // wrap it in a container to get around weirdness with parents that have css overflow auto/hidden\n    }\n\n    this.close = function() {\n        if(this.isOpen) {\n            this.isOpen = false\n            this.menu.detach()\n            //this.menu.visible = false\n            if(this.interval !== undefined) {\n                clearInterval(this.interval)\n            }\n\n            this.emit('close')\n        }\n    }\n\n    this.open = function() {\n        if(!this.isOpen) {\n            this.isOpen = true\n\n            var that = this\n\n            // find the closest component that can obscure the buttonComponent if it scrolls them above its boundaries\n            var overflowView = utils.findOverflowView(this.domNode, 'y')\n            var overflowViewBoundary = overflowView.getBoundingClientRect()\n\n            // menu positioning\n            //repositionMenu(that, overflowViewBoundary, true)  // i guess we don't need this, and it was causing annoying flicker\n            if(this.maintainDropdownPosition) {\n                // only reposition (and make visible) the menu after a return back to the scheduler, cause otherwise it doesn't take the explicit styles into account for some reason\n                this.interval = setInterval(function() {\n                    repositionMenu(that, overflowViewBoundary)\n                },50)\n            } else {\n                // only reposition (and make visible) the menu after a return back to the scheduler, cause otherwise it doesn't take the explicit styles into account for some reason\n                setTimeout(function() {\n                    repositionMenu(that, overflowViewBoundary)\n                },50)\n            }\n\n            that.menu.attach()  // attach at the top level so it isn't confined to the boundaries of its parents\n            that.emit('open')\n        }\n    }\n\n    this.toggle = function() {\n        if(this.isOpen) {\n            this.close()\n        } else {\n            this.open()\n        }\n    }\n})\n\n// repositions the dropdown component according to where the button component is on the page\n// overflowViewBoundary -  the boundingClientRect of the block who's boundaries can obscure the buttonComponent\nfunction repositionMenu(that, overflowViewBoundary, firstRepositioning) {\n    var buffer = 1 // some distance the menu is from the button (not sure why its there, but this helps work around it)\n\n    var buttonBounds = that.domNode.getBoundingClientRect()\n    var dropdown = that.menu\n\n    if(buttonBounds.bottom > overflowViewBoundary.top && buttonBounds.top < overflowViewBoundary.bottom    // make sure the button is still visible\n       && buttonBounds.right > overflowViewBoundary.left && buttonBounds.left < overflowViewBoundary.right\n    ) {\n        var dropdownStyle = getComputedStyle(that.menu.domNode) // is this expensive? Maybe store it as a property on 'that'?\n\n        setDimensionAndPosition('v', dropdown, dropdownStyle,buttonBounds, firstRepositioning)\n        setDimensionAndPosition('h', dropdown, dropdownStyle,buttonBounds, firstRepositioning)\n//        dropdown.domNode.style.left = buttonBounds.left+'px'\n        dropdown.visible = true\n    } else  {\n        that.menu.visible = false\n    }\n}\n\n// sets either the height and vertical position or the width and horizontal position, depending on the arguments\n// type - Either \"v\" or \"h\"\n// dropdown - The dropdown gem\n// dropdownStyle - A result from getComputedStyle(node)\n// buttonBounds - The BoundingClientRect of the button\nfunction setDimensionAndPosition(type, dropdown, dropdownStyle, buttonBounds, firstPositioning) {\n    if(type === 'v') {\n        var lower = 'bottom'\n        var upper = 'top'\n        var dimension = 'height'\n        var directionName = 'direction'\n\n        var potentialDimension = 'getPotentialHeight'\n        var scrollDimension = 'scrollHeight'\n        var clientDimension = 'clientHeight'\n    } else {\n        var lower = 'right'\n        var upper = 'left'\n        var dimension = 'width'\n        var directionName = 'horizontalDirection'\n\n        var potentialDimension = 'getPotentialWidth'\n        var scrollDimension = 'scrollWidth'\n        var clientDimension = 'clientWidth'\n    }\n\n    if(type === 'v') {\n        var upperOffset = buttonBounds[upper]\n        var lowerOffset = buttonBounds[lower]\n        var buffer = 1 // some distance the menu is from the button (not sure why its there, but this helps work around it)\n    } else {\n        // these are switched because in the normal case, the dropdown should be pushed right to the distance of the *left* boundary of the button (and vice versa)\n        var upperOffset = buttonBounds[lower]\n        var lowerOffset = buttonBounds[upper]\n        var buffer = 0\n    }\n\n    var dropdownMarginUpper = utils.getStylePxAmount(dropdownStyle, 'margin-'+upper)\n    var dropdownMarginLower = utils.getStylePxAmount(dropdownStyle, 'margin-'+lower)\n\n    var dropdownMargins = dropdownMarginUpper + dropdownMarginLower\n\n    if(dropdown[potentialDimension] !== undefined) {\n        var dropdownDimension = dropdown[potentialDimension]()\n    } else {\n        var dropdownDimension = dropdown.domNode[scrollDimension]\n    }\n\n    var amountCutOffDownward = lowerOffset + dropdownDimension + dropdownMargins - document.documentElement[clientDimension]\n    var amountCutOffUpward = dropdownDimension + dropdownMargins - upperOffset\n\n    if(amountCutOffDownward < 0) { // if its visible by being displayed underneath\n        var direction = 1\n        var newUpper = lowerOffset-buffer\n    } else if(amountCutOffUpward < 0) {  // if its only visible by being displayed upward\n        var direction = -1\n        var newUpper = upperOffset-dropdownDimension+buffer // puts it above rather than below - note that dropdownDimension should be the same as the clientHeight *after* this function runs (which is what we care about here)\n    } else {\n        if(amountCutOffDownward < amountCutOffUpward) { // if you can see more of the dropdown by opening it downward\n            var direction = 1\n            var newDimension = dropdownDimension+dropdownMarginLower - amountCutOffDownward\n            var newUpper = lowerOffset-buffer\n        } else {\n            var direction = -1\n            var newDimension = dropdownDimension+dropdownMarginUpper - amountCutOffUpward\n            var newUpper = newDimension-upperOffset+buffer\n        }\n    }\n\n    dropdown.domNode.style[upper] = newUpper+'px'\n    if(newDimension !== undefined) {\n        if(firstPositioning || dropdown.state.subject[dimension] !== newDimension) {\n            dropdown.domNode.style[dimension] = newDimension+'px'\n            dropdown.state.set(dimension, newDimension)\n        }\n    } else {\n        if(firstPositioning || dropdown.state.subject[dimension] !== undefined) {\n            dropdown.domNode.style[dimension] = ''\n            dropdown.state.set(dimension, undefined)\n        }\n    }\n\n    if(firstPositioning || dropdown.state.subject[directionName] !== direction) {  // don't constantly reset things if they're already that value\n        dropdown.state.set(directionName, direction)\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Dropdown.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}